from __future__ import annotations

from collections.abc import (
    ItemsView,
    Iterable,
    Iterator,
    KeysView,
    ValuesView,
)
from typing import (
    Any,
    Generic,
    Hashable,
    Protocol,
    Self,
    TypeVar,
    overload,
    override,
    runtime_checkable,
)

T = TypeVar("T")

IndexT = TypeVar("IndexT", bound=Hashable)
ValueT = TypeVar("ValueT")
ValueT_co = TypeVar("ValueT_co", covariant=True)
IndexT_contra = TypeVar("IndexT_contra", contravariant=True)
ValueT_contra = TypeVar("ValueT_contra", contravariant=True)

T_Hash = TypeVar("T_Hash", bound=Hashable, covariant=True)


@runtime_checkable
class Identifiable(Protocol, Generic[T_Hash]):
    def get_unique_identifier(self) -> T_Hash: ...


class SupportsAdding(Protocol[IndexT_contra, ValueT_contra]):
    @overload
    def add(self, index: IndexT_contra, value: ValueT_contra, /) -> None:
        """
        Overload 1: Register a value with a specific index.
        """
        ...

    @overload
    def add(self, value: ValueT_contra, /) -> None:
        """
        Overload 2: Register a value with an inferred index.
        """
        ...


class SupportsSetting(Protocol[IndexT_contra, ValueT_contra]):
    @overload
    def set(self, index: IndexT_contra, value: ValueT_contra, /) -> None:
        """
        Overload 1: Register a value with a specific index.
        """
        ...

    @overload
    def set(self, value: ValueT_contra, /) -> None:
        """
        Overload 2: Register a value with an inferred index.
        """
        ...


class Mapping(Generic[IndexT, ValueT_co], Protocol):
    def __getitem__(self, key: IndexT, /) -> ValueT_co: ...
    @overload
    def get(self, key: IndexT, /) -> ValueT_co | None: ...
    @overload
    def get(self, key: IndexT, /, default: ValueT_co) -> ValueT_co: ...  # type: ignore[misc] # pyright: ignore[reportGeneralTypeIssues] # Covariant type as parameter
    @overload
    def get(self, key: IndexT, /, default: T) -> ValueT_co | T: ...
    def items(self) -> ItemsView[IndexT, ValueT_co]: ...
    def keys(self) -> KeysView[IndexT]: ...
    def values(self) -> ValuesView[ValueT_co]: ...
    def __contains__(self, key: object, /) -> bool: ...
    @override
    def __eq__(self, other: object, /) -> bool: ...
    def __iter__(self) -> Iterator[IndexT]: ...
    def __len__(self) -> int: ...


class SupportsKeysAndGetItem(Protocol[IndexT, ValueT_co]):
    def keys(self) -> Iterable[IndexT]: ...
    def __getitem__(self, key: IndexT, /) -> ValueT_co: ...


class MutableMapping(Mapping[IndexT, ValueT], Protocol):
    def __setitem__(self, key: IndexT, value: ValueT) -> None: ...
    def __delitem__(self, key: IndexT) -> None: ...
    def clear(self) -> None: ...
    @overload
    def pop(self, key: IndexT, /) -> ValueT: ...
    @overload
    def pop(self, key: IndexT, /, default: ValueT) -> ValueT: ...
    @overload
    def pop(self, key: IndexT, /, default: T) -> ValueT | T: ...
    def popitem(self) -> tuple[IndexT, ValueT]: ...
    @overload
    def setdefault(
        self: MutableMapping[IndexT, T | None], key: IndexT, default: None = None, /
    ) -> T | None: ...
    @overload
    def setdefault(self, key: IndexT, default: ValueT, /) -> ValueT: ...
    @overload
    def update(self, m: SupportsKeysAndGetItem[IndexT, ValueT], /) -> None: ...
    @overload
    def update(
        self: Mapping[str, ValueT],
        m: SupportsKeysAndGetItem[str, ValueT],
        /,
        **kwargs: ValueT,
    ) -> None: ...
    @overload
    def update(self, m: Iterable[tuple[IndexT, ValueT]], /) -> None: ...
    @overload
    def update(
        self: Mapping[str, ValueT], m: Iterable[tuple[str, ValueT]], /, **kwargs: ValueT
    ) -> None: ...
    @overload
    def update(self: Mapping[str, ValueT], **kwargs: ValueT) -> None: ...


class Sequence(Generic[ValueT_co], Protocol):
    @overload
    def __getitem__(self, index: int) -> ValueT_co: ...
    @overload
    def __getitem__(self, index: slice) -> Sequence[ValueT_co]: ...

    def index(self, value: Any, start: int = 0, stop: int = ...) -> int: ...
    def count(self, value: Any) -> int: ...
    def __contains__(self, value: object) -> bool: ...
    def __iter__(self) -> Iterator[ValueT_co]: ...
    def __reversed__(self) -> Iterator[ValueT_co]: ...
    def __len__(self) -> int: ...


class MutableSequence(Sequence[ValueT], Protocol):
    """A generic version of collections.abc.MutableSequence."""

    def insert(self, index: int, value: ValueT) -> None: ...
    @overload
    def __getitem__(self, index: int) -> ValueT: ...
    @overload
    def __getitem__(self, index: slice) -> MutableSequence[ValueT]: ...
    @overload
    def __setitem__(self, index: int, value: ValueT) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: Iterable[ValueT]) -> None: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, index: slice) -> None: ...
    # Mixin methods
    def append(self, value: ValueT) -> None: ...
    def clear(self) -> None: ...
    def extend(self, values: Iterable[ValueT]) -> None: ...
    def reverse(self) -> None: ...
    def pop(self, index: int = -1) -> ValueT: ...
    def remove(self, value: ValueT) -> None: ...
    def __iadd__(self, values: Iterable[ValueT]) -> Self: ...
